"""
InvestMal_ai - Minimal, extendable crypto market analysis & paper-trading bot
Single-file prototype (can be split into modules).

Features:
- Fetch OHLCV from CCXT-supported exchanges
- Compute technical indicators (SMA, EMA, RSI, MACD, ATR)
- Feature engineering for ML
- Simple ML model training (RandomForest) for direction prediction
- Signal generator combining rule-based + ML probability
- Simple vectorized backtester (position sizing, slippage, commission)
- Paper-trading executor scaffold (CCXT)
- Logging and config via YAML

Caution: This is a developer prototype for research and paper trading ONLY. Do not trade live without due diligence.

Requirements (pip):
ccxt pandas numpy scikit-learn ta PyYAML joblib matplotlib

Example: pip install ccxt pandas numpy scikit-learn ta PyYAML joblib matplotlib

"""

import time
import logging
import yaml
from dataclasses import dataclass
from typing import Optional, Tuple, Dict, Any
import ccxt
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
import joblib

# ----------------------------- Config dataclass ---------------------------------

DEFAULT_CONFIG = {
    'exchange': 'binance',
    'symbol': 'BTC/USDT',
    'timeframe': '1h',
    'since_days': 365,
    'limit': 1000,
    'model_path': 'investmal_model.joblib',
    'paper_trade': True,
    'api': {
        'apiKey': '',
        'secret': ''
    },
    'backtest': {
        'initial_balance': 10000,
        'commission': 0.001,  # 0.1%
        'slippage_pct': 0.0005
    }
}

@dataclass
class InvestMalConfig:
    exchange: str
    symbol: str
    timeframe: str
    since_days: int
    limit: int
    model_path: str
    paper_trade: bool
    api: Dict[str, str]
    backtest: Dict[str, Any]

    @staticmethod
    def load(path: Optional[str] = None) -> 'InvestMalConfig':
        if path:
            with open(path, 'r') as f:
                cfg = yaml.safe_load(f)
        else:
            cfg = DEFAULT_CONFIG
        return InvestMalConfig(**cfg)

# ----------------------------- Utilities ---------------------------------------

logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s - %(message)s')
logger = logging.getLogger('InvestMal')

# ----------------------------- Data Fetcher -----------------------------------

class DataFetcher:
    def __init__(self, cfg: InvestMalConfig):
        self.cfg = cfg
        exchange_id = cfg.exchange
        self.exchange = getattr(ccxt, exchange_id)({'enableRateLimit': True})

    def fetch_ohlcv(self) -> pd.DataFrame:
        symbol = self.cfg.symbol
        timeframe = self.cfg.timeframe
        limit = self.cfg.limit
        logger.info(f'Fetching {limit} candles for {symbol} @ {timeframe} from {self.cfg.exchange}')
        since = None
        if self.cfg.since_days:
            since = int((time.time() - 24*3600*self.cfg.since_days) * 1000)
        ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since, limit=limit)
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        return df

# ----------------------------- Indicators -------------------------------------

def add_technical_indicators(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    # Simple moving averages
    df['sma_10'] = df['close'].rolling(10).mean()
    df['sma_50'] = df['close'].rolling(50).mean()
    df['ema_12'] = df['close'].ewm(span=12, adjust=False).mean()
    df['ema_26'] = df['close'].ewm(span=26, adjust=False).mean()
    # MACD
    df['macd'] = df['ema_12'] - df['ema_26']
    df['macd_signal'] = df['macd'].ewm(span=9, adjust=False).mean()
    # RSI (classic)
    delta = df['close'].diff()
    gain = delta.clip(lower=0)
    loss = -1 * delta.clip(upper=0)
    avg_gain = gain.rolling(window=14).mean()
    avg_loss = loss.rolling(window=14).mean()
    rs = avg_gain / (avg_loss + 1e-9)
    df['rsi'] = 100 - (100 / (1 + rs))
    # ATR
    high_low = df['high'] - df['low']
    high_close = np.abs(df['high'] - df['close'].shift())
    low_close = np.abs(df['low'] - df['close'].shift())
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    df['atr'] = tr.rolling(14).mean()
    # Momentum
    df['momentum_1'] = df['close'] - df['close'].shift(1)
    df['roc_12'] = df['close'].pct_change(12)
    # Drop rows with NaNs introduced by indicators
    df.dropna(inplace=True)
    return df

# ----------------------------- Feature & Label -------------------------------

def prepare_features(df: pd.DataFrame, horizon: int = 3) -> Tuple[pd.DataFrame, pd.Series]:
    df = df.copy()
    # Features (you can expand this list)
    feature_cols = ['close', 'volume', 'sma_10', 'sma_50', 'ema_12', 'ema_26', 'macd', 'macd_signal', 'rsi', 'atr', 'momentum_1', 'roc_12']
    X = df[feature_cols]
    # Label: price up (>0) after 'horizon' periods
    future_close = df['close'].shift(-horizon)
    ret = (future_close - df['close']) / df['close']
    y = (ret > 0).astype(int)  # binary classification: 1 = price up in horizon
    # Align
    valid = X.index[:-horizon]
    return X.loc[valid], y.loc[valid]

# ----------------------------- Model -----------------------------------------

class ModelManager:
    def __init__(self, cfg: InvestMalConfig):
        self.cfg = cfg
        self.model_path = cfg.model_path
        self.model: Optional[RandomForestClassifier] = None

    def train(self, X: pd.DataFrame, y: pd.Series) -> Dict[str, Any]:
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
        model = RandomForestClassifier(n_estimators=200, random_state=42, n_jobs=-1)
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        logger.info(f'Model trained — accuracy: {acc:.4f}')
        self.model = model
        joblib.dump(model, self.model_path)
        return {'accuracy': acc, 'report': classification_report(y_test, y_pred)}

    def load(self):
        try:
            self.model = joblib.load(self.model_path)
            logger.info('Model loaded from disk')
        except Exception as e:
            logger.warning(f'Failed to load model: {e}')
            self.model = None

    def predict_proba(self, X: pd.DataFrame) -> np.ndarray:
        if self.model is None:
            raise RuntimeError('Model not loaded')
        return self.model.predict_proba(X)[:, 1]

# ----------------------------- Strategy & Signals ----------------------------

class Strategy:
    def __init__(self, cfg: InvestMalConfig, model_mgr: ModelManager):
        self.cfg = cfg
        self.model_mgr = model_mgr

    def rule_based_signal(self, row: pd.Series) -> int:
        # Simple rule: golden cross + RSI filter
        signal = 0
        if row['sma_10'] > row['sma_50'] and row['rsi'] < 70 and row['rsi'] > 30:
            signal = 1
        elif row['sma_10'] < row['sma_50'] and row['rsi'] > 30:
            signal = -1
        return signal

    def combined_signal(self, X_row: pd.Series) -> Dict[str, Any]:
        rule = self.rule_based_signal(X_row)
        ml_prob = None
        ml_sig = 0
        try:
            ml_prob = float(self.model_mgr.predict_proba(X_row.to_frame().T)[0])
            ml_sig = 1 if ml_prob > 0.55 else 0
        except Exception:
            ml_prob = None
        # Combine: require both rule and ML for long
        final = 0
        if rule == 1 and ml_sig == 1:
            final = 1
        elif rule == -1:
            final = -1
        return {'rule': rule, 'ml_prob': ml_prob, 'ml_sig': ml_sig, 'final': final}

# ----------------------------- Backtester ------------------------------------

class Backtester:
    def __init__(self, cfg: InvestMalConfig):
        self.cfg = cfg
        self.initial_balance = cfg.backtest.get('initial_balance', 10000)
        self.commission = cfg.backtest.get('commission', 0.001)
        self.slippage_pct = cfg.backtest.get('slippage_pct', 0.0005)

    def run(self, df: pd.DataFrame, signals: pd.Series) -> pd.DataFrame:
        cash = self.initial_balance
        position = 0.0  # in asset units
        records = []
        for time, row in df.iterrows():
            price = row['close']
            sig = signals.loc[time]
            if sig == 1 and cash > 0:
                # buy with all cash
                size = (cash * (1 - self.commission)) / (price * (1 + self.slippage_pct))
                position += size
                cash = 0
                records.append((time, 'BUY', price, size, cash, position))
            elif sig == -1 and position > 0:
                # sell all
                proceeds = position * price * (1 - self.commission) * (1 - self.slippage_pct)
                cash += proceeds
                records.append((time, 'SELL', price, position, cash, 0))
                position = 0
            # else hold
        # close at end
        final_asset = position * df['close'].iloc[-1]
        total = cash + final_asset
        summary = pd.DataFrame(records, columns=['time', 'action', 'price', 'size', 'cash', 'position'])
        logger.info(f'Backtest finished — final balance: {total:.2f} (initial {self.initial_balance})')
        return summary

# ----------------------------- Executor (Paper trading) ----------------------

class Executor:
    def __init__(self, cfg: InvestMalConfig):
        self.cfg = cfg
        ex_cls = getattr(ccxt, cfg.exchange)
        credentials = cfg.api or {}
        self.exchange = ex_cls({'apiKey': credentials.get('apiKey', ''), 'secret': credentials.get('secret', ''), 'enableRateLimit': True})
        self.paper = cfg.paper_trade

    def place_order(self, symbol: str, side: str, amount: float, price: Optional[float] = None):
        logger.info(f'Placing order - {side} {amount} {symbol} @ {price}')
        if self.paper:
            logger.info('Paper trade enabled — not sending to exchange')
            return {'status': 'paper', 'side': side, 'amount': amount, 'price': price}
        try:
            if price:
                order = self.exchange.create_limit_order(symbol, side, amount, price)
            else:
                order = self.exchange.create_market_order(symbol, side, amount)
            return order
        except Exception as e:
            logger.error(f'Order failed: {e}')
            return {'error': str(e)}

# ----------------------------- Main flow -------------------------------------

def main(cfg_path: Optional[str] = None):
    cfg = InvestMalConfig.load(cfg_path)
    logger.info('Loaded config')
    fetcher = DataFetcher(cfg)
    df = fetcher.fetch_ohlcv()
    df = add_technical_indicators(df)
    X, y = prepare_features(df)

    model_mgr = ModelManager(cfg)
    # Try to load existing model; if not present, train new
    try:
        model_mgr.load()
    except Exception:
        pass
    if model_mgr.model is None:
        logger.info('Training new model...')
        res = model_mgr.train(X, y)
        logger.info(res.get('report'))

    strat = Strategy(cfg, model_mgr)
    # Generate signals for backtest period
    signals = pd.Series(index=X.index, dtype=int)
    for t in X.index:
        row = X.loc[t]
        s = strat.combined_signal(row)
        signals.loc[t] = s['final']

    backtester = Backtester(cfg)
    trades = backtester.run(df.loc[signals.index], signals)
    logger.info('Backtest trades:\n%s', trades)

    # Example: run real-time loop (paper trading) once — fetch latest candle, decide, optionally execute
    executor = Executor(cfg)
    latest = df.iloc[-1]
    latest_features = X.iloc[-1]
    sig = strat.combined_signal(latest_features)
    logger.info(f'Latest signal: {sig}')
    if sig['final'] == 1:
        # create a market buy for a small fraction
        amount = 0.001  # user should compute size according to balance
        executor.place_order(cfg.symbol, 'buy', amount)
    elif sig['final'] == -1:
        amount = 0.001
        executor.place_order(cfg.symbol, 'sell', amount)

if __name__ == '__main__':
    # pass path to YAML config if you have one
    main(None)
